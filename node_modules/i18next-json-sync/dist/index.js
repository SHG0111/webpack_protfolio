"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var glob = require("glob");
var path = require("path");
var ActionRecorder_1 = require("./ActionRecorder");
var LocalizationFolder_1 = require("./LocalizationFolder");
var pluralForms_1 = require("./pluralForms");
function sync(_a) {
    var _b = _a.check, isReportMode = _b === void 0 ? false : _b, _c = _a.files, files = _c === void 0 ? '**/locales/*.json' : _c, _d = _a.primary, primaryLanguage = _d === void 0 ? 'en' : _d, _e = _a.createResources, createFiles = _e === void 0 ? [] : _e, _f = _a.space, jsonSpacing = _f === void 0 ? 4 : _f, _g = _a.lineEndings, lineEndings = _g === void 0 ? 'LF' : _g, _h = _a.finalNewline, finalNewline = _h === void 0 ? false : _h, _j = _a.newKeysEmpty, newKeysEmpty = _j === void 0 ? false : _j;
    var allFiles = glob.sync(files);
    var directories = groupFilesByDirectory(allFiles);
    var targetLanguage;
    var record;
    var hasAnyErrors = false;
    var hasAnyChanges = false;
    var hasValueChanges = false;
    for (var _i = 0, _k = Object.keys(directories); _i < _k.length; _i++) {
        var currentDirectory = _k[_i];
        var folder = new LocalizationFolder_1.default(directories[currentDirectory], primaryLanguage, isReportMode);
        folder.populateFromDisk(createFiles);
        var sourceObject = folder.getSourceObject();
        if (!sourceObject) {
            continue;
        }
        for (var _l = 0, _m = folder.getFilenames(); _l < _m.length; _l++) {
            var filename = _m[_l];
            targetLanguage = normalizeLanguageFromFilename(filename);
            record = new ActionRecorder_1.default(filename, isReportMode);
            syncObjects(sourceObject, folder.getTargetObject(filename));
            record.flushToConsole();
            hasValueChanges = hasValueChanges || record.hasAnyActions();
            hasAnyErrors = hasAnyErrors || record.hasAnyErrors();
        }
        var changedFiles = folder.flushToDisk(jsonSpacing, lineEndings.toUpperCase(), finalNewline);
        hasAnyChanges = hasAnyChanges || changedFiles.length > 0;
    }
    if (hasAnyErrors) {
        throw new Error('[i18next-json-sync] found keys unsafe to synchronize');
    }
    if (isReportMode) {
        if (hasValueChanges) {
            throw new Error('[i18next-json-sync] check failed -- keys are out of sync. Run again without check mode to synchronize files');
        }
        if (hasAnyChanges) {
            throw new Error('[i18next-json-sync] check failed -- files have unordered keys or unexpected whitespace. Run again without check mode to correct files');
        }
    }
    function groupFilesByDirectory(allFiles) {
        var directories = {};
        for (var _i = 0, allFiles_1 = allFiles; _i < allFiles_1.length; _i++) {
            var filename = allFiles_1[_i];
            var directory = path.dirname(filename);
            directories[directory] = directories[directory] || {};
            directories[directory][filename] = null;
        }
        return directories;
    }
    function normalizeLanguageFromFilename(filename) {
        return path.basename(filename, '.json').replace(/-/g, '_').toLowerCase();
    }
    function syncObjects(source, target) {
        mergeKeys(source, target);
        for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
            var key = _a[_i];
            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
                // we should remove book_plural, book_1, etc if the language doesn't support singular forms
                if (typeof target[key] === 'string' && keyIsOnlyPluralForPrimary(key, Object.keys(source), Object.keys(target))) {
                    removeKey(source, target, key);
                }
            }
            else if (!isValidMappedPluralForm(key, source, target)) { // don't remove valid mappings from book_plural to book_0
                removeKey(source, target, key);
            }
        }
    }
    function mergeKeys(source, target) {
        for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
            var key = _a[_i];
            mergeKey(source, target, key);
        }
    }
    function mergeKey(source, target, key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (target.hasOwnProperty(key)) {
            if (areSameTypes(sourceValue, targetValue)) {
                if (isObject(sourceValue)) {
                    syncObjects(sourceValue, targetValue);
                }
                else if (keyMatchesPluralForLanguage(key, primaryLanguage) &&
                    !keyMatchesPluralForLanguage(key, targetLanguage)) {
                    removeKey(source, target, key);
                    mergeKeys(createPlurals(key, source), target);
                }
                //base case: source and target agree on key name and value is string
            }
            else {
                record.error(function (file) { return file + " contains type mismatch on key " + key; });
            }
        }
        else {
            copyValue(source, target, key);
        }
    }
    function copyValue(source, target, key) {
        var sourceValue = source[key];
        if (isObject(sourceValue)) {
            target[key] = {};
            syncObjects(sourceValue, target[key]);
        }
        else if (
        //do we need to transform plurals from e.g. x_plural to x_0?
        keyMatchesPluralForLanguageIncludingSingular(key, Object.keys(source), primaryLanguage) &&
            !keyMatchesPluralForLanguage(key, targetLanguage) &&
            !pluralFormsMatch()) {
            if (!targetPluralsPopulated(target, key)) {
                copyPlurals(createPlurals(key, source), target);
            }
        }
        else {
            target[key] = newKeysEmpty ? '' : sourceValue;
            record.keyAdded(key);
        }
    }
    function targetPluralsPopulated(target, key) {
        //given 'x' for key, do we have 'x' and 'x_plural' for en?
        var singular = getSingularForm(key);
        var pluralKeys = getPluralsForLanguage(targetLanguage).map(function (p) { return p.replace('key', singular); });
        var targetKeys = Object.keys(target);
        return pluralKeys.every(function (expectedPluralKeys) { return targetKeys.indexOf(expectedPluralKeys) > -1; });
    }
    function copyPlurals(plurals, target) {
        for (var _i = 0, _a = Object.keys(plurals); _i < _a.length; _i++) {
            var key = _a[_i];
            if (target.hasOwnProperty(key)) {
                continue;
            }
            target[key] = target[key] = newKeysEmpty ? '' : plurals[key];
            record.keyAdded(key);
        }
    }
    function keyIsOnlyPluralForPrimary(key, allPimaryKeys, allTargetKeys) {
        if (pluralFormsMatch()) {
            return false;
        }
        if (languageOnlyHasOneForm(primaryLanguage)) {
            return false;
        }
        return (keyMatchesPluralForLanguageIncludingSingular(key, allPimaryKeys, primaryLanguage) &&
            !keyMatchesPluralForLanguageIncludingSingular(key, allTargetKeys, targetLanguage));
    }
    function pluralFormsMatch() {
        var primaryForms = Object.keys(getPluralsForLanguage(primaryLanguage));
        var targetForms = Object.keys(getPluralsForLanguage(targetLanguage));
        return (primaryForms.length === targetForms.length &&
            primaryForms.every(function (form) { return targetForms.indexOf(form) > -1; }));
    }
    function keyMatchesPluralForLanguageIncludingSingular(key, allKeys, language) {
        /**
         * It's impossible to tell whether a key is a plural for a language with one form shared between singular and plurals.
         * With other languages we can look for relationships between e.g. value and value_plural or value and value_0.
         */
        if (languageOnlyHasOneForm(language)) {
            return true;
        }
        var matchesAPlural = keyMatchesPluralForLanguage(key, language);
        if (matchesAPlural) {
            return true;
        }
        //key is now a singular form
        if (!languageHasSingularForm(language)) {
            return false;
        }
        for (var _i = 0, allKeys_1 = allKeys; _i < allKeys_1.length; _i++) {
            var _key = allKeys_1[_i];
            if (key !== _key && isPluralFormForSingular(_key, key, language)) {
                return true;
            }
        }
        return false;
    }
    function keyMatchesPluralForLanguage(key, language) {
        var forms = getPluralsForLanguage(language).map(function (form) { return form.replace('key', ''); });
        for (var _i = 0, forms_1 = forms; _i < forms_1.length; _i++) {
            var form = forms_1[_i];
            if (form && key.endsWith(form)) {
                return true;
            }
        }
        return false;
    }
    function isValidMappedPluralForm(key, sourceObject, targetObject) {
        var singular = getSingularForm(key);
        var isPluralForPrimaryLanguage = Object.keys(sourceObject).some(function (key) { return isPluralFormForSingular(key, singular, primaryLanguage); });
        if (languageOnlyHasOneForm(targetLanguage)) {
            return singular === key && isPluralForPrimaryLanguage;
        }
        var isPluralForTargetLanguage = Object.keys(targetObject).some(function (key) { return isPluralFormForSingular(key, singular, targetLanguage); });
        return isPluralForPrimaryLanguage && isPluralForTargetLanguage;
    }
    function getSingularForm(key) {
        return key.replace(/_(plural|\d)$/, '');
    }
    function isPluralFormForSingular(key, singular, language) {
        return getPluralsForLanguage(language)
            .map(function (form) { return form.replace('key', singular); })
            .indexOf(key) > -1;
    }
    function languageHasSingularForm(language) {
        return getPluralsForLanguage(language)
            .map(function (form) { return form.replace('key', ''); })
            .indexOf('') > -1;
    }
    function languageOnlyHasOneForm(language) {
        return getPluralsForLanguage(language).length === 1;
    }
    function getPluralsForLanguage(language) {
        if (pluralForms_1.default.hasOwnProperty(language)) {
            return pluralForms_1.default[language];
        }
        if (language.indexOf('_') > -1 || language.indexOf('-') > -1) {
            var baseLanguage = language.split(/-|_/)[0];
            if (pluralForms_1.default.hasOwnProperty(baseLanguage)) {
                return pluralForms_1.default[baseLanguage];
            }
        }
        return [];
    }
    function createPlurals(key, source) {
        var singular = getSingularForm(key);
        var plurals = {};
        if (languageOnlyHasOneForm(primaryLanguage)) {
            plurals[key] = source[key];
        }
        else {
            var fillValue = getPluralFillValue(singular, source);
            for (var _i = 0, _a = getPluralsForLanguage(targetLanguage); _i < _a.length; _i++) {
                var form = _a[_i];
                plurals[form.replace('key', singular)] = fillValue;
            }
        }
        return plurals;
    }
    function getPluralFillValue(singular, source) {
        if (languageOnlyHasOneForm(primaryLanguage)) {
            return source[singular];
        }
        //prefer plural fill values because they're more likely to have
        //interpolations like {{ count }}, but fall back to singular
        var sourceKeys = Object.keys(source).filter(function (k) { return k !== singular; });
        for (var _i = 0, _a = getPluralsForLanguage(primaryLanguage); _i < _a.length; _i++) {
            var form = _a[_i];
            var pluralKey = form.replace('key', singular);
            if (sourceKeys.indexOf(pluralKey) > -1) {
                return source[pluralKey];
            }
        }
        return source[singular];
    }
    function removeKey(source, target, key) {
        if (isObject(target[key])) {
            gatherKeysFor(target[key]).forEach(function (k) { return record.keyRemoved(k); });
        }
        else {
            record.keyRemoved(key);
        }
        //base case: key in target not found in source
        delete target[key];
    }
    function gatherKeysFor(object) {
        return Object.keys(object)
            .map(function (key) { return gatherPrimitivesForSingleKey(object, key); })
            .reduce(function (all, next) { return all.concat(next); }, []);
    }
    function gatherPrimitivesForSingleKey(object, key) {
        if (isObject(object[key])) {
            return gatherKeysFor(object[key]);
        }
        else {
            return [key];
        }
    }
}
exports.default = sync;
function isObject(value) {
    return getTypeName(value) === 'Object';
}
function areSameTypes(value, otherValue) {
    return getTypeName(value) === getTypeName(otherValue);
}
function getTypeName(object) {
    var fullName = Object.prototype.toString.call(object);
    return fullName.split(' ')[1].slice(0, -1);
}
//# sourceMappingURL=index.js.map